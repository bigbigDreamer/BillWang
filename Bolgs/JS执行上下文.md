# JS执行上下文
#### 作者：王彬林 &nbsp;&nbsp; &nbsp; &nbsp; &nbsp; &nbsp;   时间：2018.10.18 /PM 16:27

>前言：我们都可以理解的是JS声明一个变量的基本形式：let a = 13;其实这个两个过程，一般人都会不自觉的将它认定为是一个步骤，
let a 是声明部分，a = 13是赋值部分，声明部分发生在编译阶段，而赋值部分发生在执行阶段。由于JS是解释性语言，也就是一边
编译，一边执行的过程。

```bash
     //在ES5.1规范中
     console.log(a);//undefined
     var a  = 18;
     /* 很显然这是发生了变量提升，定义一个全局变量的同时，其实它也就是一个window的属性，调用的时候完全可以通过
      * window.a的形式去调用 。
      */
```
--------------------------------------------------------------------

```bash
    //ES6新规范中
    console.log(a);//编译器直接报错，因为let引进了一个块级作用域，完全的隔离的变量提升的空间。
    let a = 18;
```

##### 话不多说，正式介绍JS执行上下文
> ### 什么叫执行上下文？
>>我来谈谈我个人的理解，上下文其实就是当前代码块的context与scope的互相依赖，执行上下文说白了就是确定这段执行代码块在当前环境或者作用域下中的this指向。
>
> ### 上下文运行环境分类
>>1.全局级别的代码，一旦代码被载入，引擎最先进入这个环境；
>>
>>2.函数级别的代码，当执行函数时，执行函数体中的代码；
>>
>>3.eval中的代码
> ### 执行上下文的组成
>>变量对象（Variable object，VO）: 变量对象，即包含变量的对象，除了我们无法访问它外，和普通对象没什么区别;
>>
>>[[Scope]]属性:数组。作用域链是一个由变量对象组成的带头结点的单向链表，其主要作用就是用来进行变量查找。而[[Scope]]属性是一个指向这个链表头节点的指针;
>>
>>this: 指向一个环境对象，注意是一个对象，而且是一个普通对象，而不是一个执行环境。
>
> ### 若干执行上下文会构成一个执行上下文栈（Execution context stack，ECS）。
>> ###### 在每次执行上下文对象的时候会进行压栈操作，最后的上下文执行对象会被压入栈顶。
>> ![alt](https://github.com/bigbigDreamer/BillWang/blob/master/imgBox/execution.png)
>
> ### 产生执行上下文的两个阶段(JS解释器会通过两个阶段去创建一个EC)
>>创建阶段（当函数被调用，但是开始执行函数内部代码之前）
>> - 创建变量对象VO
>> - 设置[[Scope]]属性的值
>> - 设置this的值
>> - 激活/代码执行阶段
>>
>>代码执行阶段
>> - 执行函数体中的代码，一行一行地运行代码，给variableObject中的变量属性赋值。
>> - 初始化变量对象，即设置变量的值、函数的引用，然后解释/执行代码。

```bash
    // 执行上下文所包含的三个属性
      executionContextObj = {
      variableObject: {
        /* 函数中的arguments对象, 参数, 内部的变量以及函数声明 */
           global_var1：undefined
           global_function1：函数 global_function1的地址
           global_sum：undefined
                     },
      scope: {
        /* variableObject 以及所有父执行上下文中的variableObject */
              global_context.Variable_Object
                    },
      this: {
           undefined
          },
      }
```
>小结
>>日常我们接触到的就只有函数执行的上下文对象，有个小面试题目就是，n函数执行，请问有几个上下文产生?
答案很明了，一开始解释器最先接触的就是全局上下文，所以答案是 n+1
